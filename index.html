<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>冯义星的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="冯义星的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冯义星的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冯义星的博客">
  
    <link rel="alternate" href="/atom.xml" title="冯义星的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">冯义星的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/JS-DOM/" class="article-date">
  <time datetime="2019-06-18T15:37:03.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/JS-DOM/">JS-DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型：<code>Document Object Model</code>是<code>HTML</code>和<code>XML</code>文档的编程接口</p>
<h3 id="Node接口"><a href="#Node接口" class="headerlink" title="Node接口"></a>Node接口</h3><p>Node(节点)是一个接口，许多<code>DOM API</code>都会继承这个接口，如<code>Document</code>、<code>Element</code>、<code>Text</code></p>
<h5 id="Node常用属性"><a href="#Node常用属性" class="headerlink" title="Node常用属性"></a><code>Node</code>常用属性</h5><p><code>childNodes</code>:获取所有子节点</p>
<p><code>firstChild</code>：获取第一个子节点</p>
<p><code>lastChild</code>：获取最后一个子节点</p>
<p><code>nodeName</code>：通过该属性获取的是节点名是大写格式的，后加入的<code>svg</code>除外</p>
<p><code>nodeType</code>：节点类型，<code>1-Node.ELEMENT_NODE</code>、<code>3-Node.TEXT_NODE</code></p>
<p><code>parentNode</code>：获取父节点</p>
<p><code>previousSibling</code>：获取上一个兄弟节点</p>
<p><code>nextSibling</code>：获取下一个兄弟节点</p>
<p><code>Node</code>(节点)的类型很多，如注释节点、文本节点等，易忽略的是换行和空格也会构成文本节点</p>
<hr>
<h5 id="Node常用方法"><a href="#Node常用方法" class="headerlink" title="Node常用方法"></a><code>Node</code>常用方法</h5><p><code>appendChild()</code>：添加子节点</p>
<p><code>cloneNode()</code>：克隆节点，可以传入布尔值；默认浅拷贝，传入<code>true</code>后是深拷贝</p>
<p><code>isEqualNode()</code>：判断两个节点是否相同</p>
<p><code>isSameNode()</code>：判断两个节点是否是同一个节点</p>
<p><code>normalize()</code>：标准化，常见的将同时添加的两个文本节点转化为一个文本节点</p>
<hr>
<h3 id="Document接口"><a href="#Document接口" class="headerlink" title="Document接口"></a>Document接口</h3><p>指整个加载好的网页，是操作<code>DOM</code>树的入口</p>
<p><code>document</code>是浏览器全局对象<code>window</code>的一个属性，原型是<code>HTMLDocument.prototype</code></p>
<h5 id="Document常用属性"><a href="#Document常用属性" class="headerlink" title="Document常用属性"></a><code>Document</code>常用属性</h5><p><code>body</code>：获取body节点</p>
<p><code>characterSet</code>：获取当前页面字符编码</p>
<p><code>doctype</code>：获取文档类型</p>
<p><code>documentElement</code>：获取文档元素，不包括doctype</p>
<p><code>location</code>：获取网页URI</p>
<p>浏览器加载<code>document</code>的过程：<code>open -&gt; write -&gt; close</code>(页面加载完毕后自动执行)</p>
<p>所以如果异步向页面写入内容，会覆盖之前页面中的内容，因为有网页关闭后在重新开启的过程</p>
<h5 id="Document常用方法"><a href="#Document常用方法" class="headerlink" title="Document常用方法"></a><code>Document</code>常用方法</h5><p><code>createElement()</code>：创建一个元素节点，在<code>HTML</code>中元素特指标签</p>
<p><code>createTextNode()</code>：创建一个文本节点</p>
<p><code>getElementById()</code>：获取某个DOM节点</p>
<p><code>getElementsByClassName()</code>、<code>getElementsByTagName()</code>：获取一组DOM节点</p>
<hr>
<h3 id="Element接口"><a href="#Element接口" class="headerlink" title="Element接口"></a>Element接口</h3><p><strong>特有属性</strong></p>
<p><code>tagName</code>：获取标签名，是大写格式的</p>
<p><code>classList</code>：获取class属性伪数组</p>
<p><code>children</code>：获取所有子元素</p>
<p><code>previousElementSibling</code>：前一个兄弟元素</p>
<p><code>nextElementSibling</code>：下一个兄弟元素</p>
<p><strong>优化查找DOM元素的方法</strong></p>
<p><code>querySelector()</code>：获取匹配指定选择器的第一个元素</p>
<p><code>querySelectorAll()</code>：获取匹配指定选择器的一组元素</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/18/JS-DOM/" data-id="cjx21g4v20002bsvagatse5ls" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/JS函数/" class="article-date">
  <time datetime="2019-06-18T10:05:11.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/JS函数/">JS函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="函数的5种声明方式"><a href="#函数的5种声明方式" class="headerlink" title="函数的5种声明方式"></a>函数的5种声明方式</h3><h5 id="1、具名函数"><a href="#1、具名函数" class="headerlink" title="1、具名函数"></a>1、具名函数</h5><p>指有具体名称的函数</p>
<p>如：<code>function fn(){ return undefined }</code>，<code>fn.name -&gt; fn</code></p>
<h5 id="2、匿名函数"><a href="#2、匿名函数" class="headerlink" title="2、匿名函数"></a>2、匿名函数</h5><p>一般要赋值给一个变量进行调用，且要放在调用前声明</p>
<p>如：<code>var fn = function(){ return undefined }</code>，<code>fn.name -&gt; fn</code></p>
<h5 id="3、将具名函数赋值给变量"><a href="#3、将具名函数赋值给变量" class="headerlink" title="3、将具名函数赋值给变量"></a>3、将具名函数赋值给变量</h5><p><code>var fn1 = function fn(){ return undefined }</code>，<code>fn1.name -&gt; fn</code></p>
<p>这种声明方式下，<code>fn</code>只能在函数体里才能访问，外部访问会报错</p>
<h5 id="4、使用内置函数Function声明"><a href="#4、使用内置函数Function声明" class="headerlink" title="4、使用内置函数Function声明"></a>4、使用内置函数Function声明</h5><p><code>var fn = new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x+y&#39;)</code>，<code>fn.name -&gt; anonymous</code></p>
<p>这种声明方式比较繁琐，很少用到，而且其<code>name</code>属性值为<code>anonymous</code></p>
<h5 id="5、ES6箭头函数"><a href="#5、ES6箭头函数" class="headerlink" title="5、ES6箭头函数"></a>5、ES6箭头函数</h5><p>用法同匿名函数，但写法要简洁很多</p>
<p>语法：<code>var fn = ()=&gt;{}</code>，<code>fn.name -&gt; fn</code></p>
<p><code>()</code>中放参数列表，若只有一个参数，<code>()</code>可以省略不写</p>
<p><code>{}</code>中放函数体，如果只有一条<code>return</code>语句，可以省略<code>{}</code>和<code>return</code>关键字；若返回的是一个对象，省略后要用<code>()</code>包裹对象</p>
<hr>
<h3 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h3><p>函数本质是一个对象</p>
<p>可描述为：<code>var fn = { params:[&#39;x&#39;,&#39;y&#39;], fBody:&#39;return x+y&#39;, call:function(){ eval(fn.fBody) }}</code></p>
<h5 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h5><p><code>f(1, 2)</code>是<code>f.call(undefined, 1, 2)</code>的语法糖</p>
<h3 id="this和arguments"><a href="#this和arguments" class="headerlink" title="this和arguments"></a>this和arguments</h3><p><code>call</code>的第一个参数可以用<code>this</code>得到</p>
<p><code>call</code>的第一个参数后面的参数可用<code>arguments</code>得到</p>
<h3 id="call-stack"><a href="#call-stack" class="headerlink" title="call stack"></a>call stack</h3><p>调用栈</p>
<p>先进后出，指后调用的函数先执行，一般是指函数中嵌套其他函数</p>
<p>如同递归，先执行目标函数，层层递进到结束点，再从结束点回归到目标函数</p>
<p>常见错误：<code>stack overflow</code>堆栈溢出，是递归深度超过了最大限制而报出的错误</p>
<hr>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>可用用树结构来描述作用域</p>
<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>当使用一个变量时，会先在当前作用域中找</p>
<p>若没有就去上一级作用域，依次往上查找，直至顶层<code>window</code>作用域</p>
<p><code>a=3</code>这个表达式是赋值，若当前作用域中无<code>a</code>变量的声明，就会沿着作用域链去查找</p>
<p>如果一直找不到，就会成为一个全局变量，即给<code>window</code>下的变量<code>a</code>赋值为<code>3</code></p>
<h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p>在JS一行一行执行代码之前，会进行预解析，将声明提前</p>
<p>1、变量声明，如<code>var a=1</code>这个表达式包括声明和赋值，故会将<code>var a</code>提到最前面</p>
<p>若在<code>var a=1</code>之前使用了<code>a</code>变量，JS会视为已声明未赋值而默认赋值为<code>undefined</code></p>
<p>2、函数声明，会将函数声明提前，这样函数就可以定义在调用代码之后了，函数体内部也存在变量提升</p>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>如果一个函数使用了它范围外的变量，那么 <code>这个函数+这个变量</code> 就构成了闭包</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/18/JS函数/" data-id="cjx21g4v40003bsva3n7db8q0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS数组和伪数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/JS数组和伪数组/" class="article-date">
  <time datetime="2019-06-17T15:51:17.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/JS数组和伪数组/">JS数组和伪数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>一种术语，指浏览器提供给JS的<code>API</code></p>
<h3 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h3><h5 id="Number、String、Boolean"><a href="#Number、String、Boolean" class="headerlink" title="Number、String、Boolean"></a><code>Number</code>、<code>String</code>、<code>Boolean</code></h5><p>不加<code>new</code>，用于类型转换</p>
<p>加<code>new</code>，用于创建相应对象</p>
<h5 id="Object、Array、Function"><a href="#Object、Array、Function" class="headerlink" title="Object、Array、Function"></a><code>Object</code>、<code>Array</code>、<code>Function</code></h5><p>加不加<code>new</code>关键字都表示创建对象</p>
<p><strong><em>Object</em></strong></p>
<p><code>var obj = {}</code>是<code>var obj = new Object()</code>的语法糖</p>
<p><strong><em>Array</em></strong></p>
<p><code>var arr = []</code>是<code>var arr = new Array()</code>的语法糖</p>
<p>但<code>Array(3)</code>表示创建一个长度为3的数组，并不是<code>[3]</code></p>
<p>因为<code>Array</code>只传一个参数且为数字时，必须是自然数，且表示的是数组长度</p>
<p><strong><em>Function</em></strong></p>
<p>使用关键字创建函数：<code>function fn(){}</code>，ES6箭头函数<code>() =&gt; {}</code></p>
<p>使用内置函数创建函数：<code>var fn = new Function(&#39;a&#39;,&#39;b&#39;,&#39;return a-b&#39;)</code></p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的本质是<code>__proto__</code>属性指向<code>Array.prototype</code>的对象</p>
<p>数组也可以扩展属性，只是遍历的时候使用的<code>key</code>值为数字，一般不会遍历到自定义的属性而已</p>
<h5 id="数组首尾操作API"><a href="#数组首尾操作API" class="headerlink" title="数组首尾操作API"></a>数组首尾操作API</h5><p><code>push(data)</code>：在数组的末尾追加一个元素</p>
<p><code>pop()</code>：删除数组最后一个元素</p>
<p><code>unshift(data)</code>：在数组开头插入一个元素</p>
<p><code>shift()</code>：删除数组的首个元素</p>
<h5 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h5><p>某一对象中也有类似数组以自然数为<code>key</code>值得键值对</p>
<p>但原型链中没有<code>Array.prototype</code>这一环，如<code>arguments</code>(参数伪数组)对象</p>
<hr>
<h3 id="数组常用API"><a href="#数组常用API" class="headerlink" title="数组常用API"></a>数组常用API</h3><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a><code>concat</code></h5><p>返回两个数组连接生成的新数组，<code>arr1.concat(arr2)</code></p>
<p>巧妙用于进行数组的深拷贝：<code>arr2 = arr1.concat([])</code></p>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h5><p>将数组转换为字符串，默认以逗号连接</p>
<p>即<code>arr.toString()</code>等效于<code>arr.join()</code></p>
<p>数组转字符串<code>arr.join(&#39;&#39;)</code>，字符串转字符数组<code>str.split(&#39;&#39;)</code></p>
<hr>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h5><p>用于进行数组排序</p>
<p>语法：<code>sort(function(a, b){ return a-b }</code>表示从小到大排序</p>
<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h5><p>用于遍历数组，无返回值</p>
<p>语法：<code>forEach(function(item, index){})</code></p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h5><p>映射，将当前数组元素进行指定操作，返回新数组</p>
<p>语法：<code>map(function(item, index){ return item*2 }</code>将所有元素扩大两倍</p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h5><p>过滤，将当前数组中符合条件的元素过滤出来，组成新数组</p>
<p>语法：<code>filter(function(item, index){ return item%2 }</code>获取所有奇数</p>
<hr>
<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><code>reduce</code></h5><p>减少，将数组中的元素依次进行某项操作，返回一个值</p>
<p>语法：<code>reduce(function(prev, cur){ return prev+cur }, initial)</code></p>
<p>可以用<code>reduce</code>方法表示<code>map</code>和<code>filter</code>，或是实现<code>forEach</code>的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//使用reduce表示map将数组元素*2</span></span><br><span class="line"><span class="keyword">var</span> arr1 = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    prev.push(cur * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="comment">//使用reduce表示filter过滤出数组中的奇数</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    cur % <span class="number">2</span> &amp;&amp; prev.push(cur)</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="comment">//使用reduce表示forEach求数组中偶数项的和</span></span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">    cur % <span class="number">2</span> || (prev += cur)</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/17/JS数组和伪数组/" data-id="cjx21g4vd0008bsvau93urimk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS原型和原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/JS原型和原型链/" class="article-date">
  <time datetime="2019-06-16T09:50:31.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/16/JS原型和原型链/">JS原型和原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>浏览器全局对象：<code>window</code></p>
<p><code>ECMAScript</code>全局对象：<code>global</code></p>
<h3 id="window常用属性"><a href="#window常用属性" class="headerlink" title="window常用属性"></a>window常用属性</h3><p><code>alert(data)</code>：警告弹框，给用户传达某些信息</p>
<p><code>prompt(desc)</code>：提示填写框，返回用户输入的值</p>
<p><code>confirm(desc)</code>：确认弹框，返回的是一个布尔值</p>
<p><code>console</code>：控制台，开发者常用属性，如<code>console.log</code></p>
<p><code>document</code>：文档对象，属于<code>DOM</code>对象</p>
<p><code>history</code>：历史对象，属于<code>BOM</code>对象</p>
<p><code>setTimeout( function(){}, time )</code>：定时器</p>
<hr>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>可将其他类型转换成数字，也可用来创建<code>Number</code>对象</p>
<p><code>var n = 1; n.toString()</code>底层原理</p>
<p>临时创建<code>new Number(n)</code>对象(将基本数字包装成一个<code>Number</code>对象)</p>
<p>然后通过此对象调用<code>toString()</code>方法，返回结果后，再将此对象销毁</p>
<p>故：<code>n.xxx = 2 , console.log(n.xxx) -&gt; undefined</code></p>
<hr>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p>用于将其他类型转换成字符串，也可用来创建<code>String</code>对象</p>
<p>通过字符串调用方法的底层原理和数字调用属性/方法原理相同</p>
<p>常用方法</p>
<h5 id="trim"><a href="#trim" class="headerlink" title="trim()"></a><code>trim()</code></h5><p>用于去除字符串两端空格</p>
<h5 id="charAt-index"><a href="#charAt-index" class="headerlink" title="charAt(index)"></a><code>charAt(index)</code></h5><p>获取指定位置字符</p>
<h5 id="indexOf-str"><a href="#indexOf-str" class="headerlink" title="indexOf(str)"></a><code>indexOf(str)</code></h5><p>获取字符或子串的位置，子串获得的是其首个字符在目标字符串中的位置</p>
<h5 id="slice-startIndex-endIndex"><a href="#slice-startIndex-endIndex" class="headerlink" title="slice(startIndex, endIndex)"></a><code>slice(startIndex, endIndex)</code></h5><p>截取指定(左闭右开)区间的子串</p>
<p><code>startIndex</code>为负数，会默认加上<code>length</code></p>
<p><code>endIndex</code>缺省或大于<code>length</code>时，会默认指定为<code>length</code></p>
<h5 id="substring-startIndex-endIndex"><a href="#substring-startIndex-endIndex" class="headerlink" title="substring(startIndex, endIndex)"></a><code>substring(startIndex, endIndex)</code></h5><p>作用同<code>slice</code>，但<code>startIndex</code>为负数时，会视为<code>0</code>处理</p>
<h5 id="substr-startIndex-count"><a href="#substr-startIndex-count" class="headerlink" title="substr(startIndex, count)"></a><code>substr(startIndex, count)</code></h5><p>从指定位置开始，截取指定长度的子串</p>
<p>当<code>start + count &gt; length</code>时，会默认指定为<code>length</code>，即截取到末尾</p>
<h5 id="s1-concat-s2"><a href="#s1-concat-s2" class="headerlink" title="s1.concat(s2)"></a><code>s1.concat(s2)</code></h5><p>将两个字符串拼接，返回一个新的字符串</p>
<h5 id="replace-REG-ig-target"><a href="#replace-REG-ig-target" class="headerlink" title="replace(/REG/ig, target)"></a><code>replace(/REG/ig, target)</code></h5><p>将字符串中符合正则匹配的都替换为目标字符串</p>
<p><code>i：ignoreCase</code>忽略大小写，<code>g：global</code>全局</p>
<p>若不使用参数，可用字符串代替正则，默认只会替换第一处匹配的结果</p>
<hr>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>对象的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>属性</p>
<p>如<code>var obj = {}(new Object())</code></p>
<p><code>obj</code>是一个对象，它的<code>__proto__</code>属性指向其构造函数<code>Object</code>的<code>prototype</code>属性<br>即<code>obj.__proto__ === Object.prototype</code></p>
<p>而<code>Object.prototype</code>也是一个对象，它的<code>__proto__</code>属性指向<code>null</code></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>通过对象调用属性/方法，若该对象中没有此属性，</p>
<p>就会去它的(隐式)原型<code>obj.__proto__</code>中找，即去其构造函数的(显式)原型<code>fn.prototype</code>中找</p>
<p>如果还没找到，就会去其原型的原型<code>obj.__proto__.__proto__</code>中找，层层向上直到一个对象的原型对象为<code>null</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/JS原型和原型链/" data-id="cjx21g4v90006bsvag0fn9tl5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS类型转换与内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/JS类型转换与内存/" class="article-date">
  <time datetime="2019-06-15T13:51:44.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/15/JS类型转换与内存/">JS类型转换与内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="转字符串"><a href="#转字符串" class="headerlink" title="转字符串"></a>转字符串</h3><h5 id="1、toString-方法"><a href="#1、toString-方法" class="headerlink" title="1、toString()方法"></a>1、<code>toString()</code>方法</h5><p>除<code>null</code>和<code>undefined</code>以外的数据类型都有此方法</p>
<p>对象使用此方法获得的是<code>&quot;[object Object]&quot;</code></p>
<h5 id="2、String-data-方法"><a href="#2、String-data-方法" class="headerlink" title="2、String(data)方法"></a>2、<code>String(data)</code>方法</h5><p>可以将任意类型的数据转换成字符串</p>
<h5 id="3、在数据后面加空字符串-39-39"><a href="#3、在数据后面加空字符串-39-39" class="headerlink" title="3、在数据后面加空字符串+&#39;&#39;"></a>3、在数据后面加空字符串<code>+&#39;&#39;</code></h5><p>因为+只操作相同类型的数据，故其他类型与字符串相加时</p>
<p>会先调用String()方法将其他类型的数据转换成字符串再运算</p>
<hr>
<h3 id="转布尔值"><a href="#转布尔值" class="headerlink" title="转布尔值"></a>转布尔值</h3><p>1、<code>Boolean(data)</code>方法</p>
<p>2、在数据前加两个逻辑非运算符<code>!!</code></p>
<p>五个falsy值：<code>0</code>、<code>NaN</code>、<code>&#39;&#39;</code>、<code>null</code>、<code>undefined</code></p>
<hr>
<h3 id="转数字"><a href="#转数字" class="headerlink" title="转数字"></a>转数字</h3><h5 id="1、Number-data-方法"><a href="#1、Number-data-方法" class="headerlink" title="1、Number(data)方法"></a>1、<code>Number(data)</code>方法</h5><p>这种方法将字符串转成数字只能转纯数字字符串，否则会得到NaN(Not a Number)</p>
<h5 id="2、parseInt-data-、parseFloat-data-方法"><a href="#2、parseInt-data-、parseFloat-data-方法" class="headerlink" title="2、parseInt(data)、parseFloat(data)方法"></a>2、<code>parseInt(data)</code>、<code>parseFloat(data)</code>方法</h5><p>解析数字字符，按从左到右的顺序能解析多少个就解析多少个，遇到不能解析的就返回已解析的结果</p>
<h5 id="3、减零法-0"><a href="#3、减零法-0" class="headerlink" title="3、减零法-0"></a>3、减零法<code>-0</code></h5><p>底层使用的转换方法是<code>Number()</code></p>
<h5 id="4、取正法"><a href="#4、取正法" class="headerlink" title="4、取正法"></a>4、取正法</h5><p>在数据前加<code>+</code>号，即可将其转换成数字，底层使用的也是<code>Number()</code>方法</p>
<hr>
<h3 id="内存和硬盘"><a href="#内存和硬盘" class="headerlink" title="内存和硬盘"></a>内存和硬盘</h3><p>内存，断电即失，读写数据快</p>
<p>硬盘，持久存储，读写速度慢，如SSD固态硬盘、机械硬盘</p>
<hr>
<h3 id="JS内存"><a href="#JS内存" class="headerlink" title="JS内存"></a>JS内存</h3><p>浏览器会将电脑分配给JS的内存氛围代码区和数据区</p>
<p>数据区又划分为：</p>
<h5 id="1、栈内存-Stack"><a href="#1、栈内存-Stack" class="headerlink" title="1、栈内存(Stack)"></a>1、栈内存(Stack)</h5><p>用来存储基本数据类型和64位内存地址(对象的引用)</p>
<h5 id="2、堆内存-Heap"><a href="#2、堆内存-Heap" class="headerlink" title="2、堆内存(Heap)"></a>2、堆内存(Heap)</h5><p>因为对象可扩展属性，存在栈内存中扩展很消耗性能(类似向数组中插入数据)</p>
<p>故将引用数据类型存储在堆内存中，通过引用操纵对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125; <span class="comment">//a = ADDR45</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">//b = ADDR45</span></span><br><span class="line"><span class="comment">/**浏览器执行顺序从左到右</span></span><br><span class="line"><span class="comment"> * 但赋值运算符运算顺序从右到左</span></span><br><span class="line"><span class="comment"> * 故a.x = ADDR45.x, a = &#123; n: 2 &#125;-ADDR55, a.x = ADDR55 */</span></span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125; </span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">//ADDR55.x = undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">//ADDR45.x = &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收(GC)"></a>垃圾回收(GC)</h3><p>如果一个对象没有被引用，他就是垃圾，将被回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125; <span class="comment">//函数1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = fn</span><br><span class="line"></span><br><span class="line">fn = <span class="literal">null</span><span class="comment">//此时函数1还不是垃圾，因为还有document.body.oclick引用它</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="literal">null</span><span class="comment">//此时函数1已不被引用，就会视作垃圾进行回收</span></span><br></pre></td></tr></table></figure>

<h3 id="引用类型的-浅拷贝和深拷贝"><a href="#引用类型的-浅拷贝和深拷贝" class="headerlink" title="(引用类型的)浅拷贝和深拷贝"></a>(引用类型的)浅拷贝和深拷贝</h3><h5 id="浅拷贝，拷贝的是引用"><a href="#浅拷贝，拷贝的是引用" class="headerlink" title="浅拷贝，拷贝的是引用"></a>浅拷贝，拷贝的是引用</h5><p><code>var a = {}; var b = a</code> b改变会影响a</p>
<h5 id="深拷贝，拷贝的是值"><a href="#深拷贝，拷贝的是值" class="headerlink" title="深拷贝，拷贝的是值"></a>深拷贝，拷贝的是值</h5><p><code>var a = {}; var b = JSON.parse(JSON.stringify(a))</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/JS类型转换与内存/" data-id="cjx21g4vi000absvaplddwb9e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/14/JS数据类型/" class="article-date">
  <time datetime="2019-06-14T14:53:31.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/JS数据类型/">JS数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="7种数据类型"><a href="#7种数据类型" class="headerlink" title="7种数据类型"></a>7种数据类型</h3><p>包括6种基本数据类型和1种引用数据类型</p>
<hr>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h5 id="1、数字-number"><a href="#1、数字-number" class="headerlink" title="1、数字 number"></a>1、数字 <code>number</code></h5><p>整数：1</p>
<p>浮点数：1.1、.1</p>
<p>科学计数：1.23e2</p>
<p>二进制：0b11，八进制：011、0o11，十六进制：0x10</p>
<h5 id="2、字符串-string"><a href="#2、字符串-string" class="headerlink" title="2、字符串 string"></a>2、字符串 <code>string</code></h5><p>单行字符串：使用引号包裹(<code>&#39;&#39;</code>、<code>&quot;&quot;</code>)</p>
<p>空字符串<code>&#39;&#39;</code>长度为0，和空格字符串<code>&#39; &#39;</code>不同</p>
<p>多行字符串，ES6中使用反引号，这种方式的多行字符串中包括换行符，每个占一个长度<br>(在此之前也可以在要换行的地方加<code>\</code>，但使用这种方法若<code>\</code>后面加了空格引起BUG很难排查)</p>
<p>字符串中出现引号的解决方法：1、单双引号嵌套，2、使用转义字符<code>\</code></p>
<h5 id="3、布尔类型-boolean"><a href="#3、布尔类型-boolean" class="headerlink" title="3、布尔类型 boolean"></a>3、布尔类型 <code>boolean</code></h5><p><code>true</code>和<code>false</code></p>
<p>逻辑运算：<code>&amp;&amp;</code>与、<code>||</code>或，返回能决定整个表达式真假的表达式的运算结果</p>
<h5 id="4、符号类型-symbol"><a href="#4、符号类型-symbol" class="headerlink" title="4、符号类型 symbol"></a>4、符号类型 <code>symbol</code></h5><p>通过<code>Symbol()</code>来创建symbol类型的数据，此数据不会重复</p>
<h5 id="5、null"><a href="#5、null" class="headerlink" title="5、null"></a>5、<code>null</code></h5><p>空对象指针，null类型只有一个取值就是null，但<code>typeof(null)</code>结果是<code>object</code></p>
<h5 id="6、undefined"><a href="#6、undefined" class="headerlink" title="6、undefined"></a>6、<code>undefined</code></h5><p>未定义，变量只有声明，未被赋值，就会默认赋值为undefined</p>
<hr>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h5 id="7、对象-object"><a href="#7、对象-object" class="headerlink" title="7、对象 object"></a>7、对象 <code>object</code></h5><p>哈希表，是引用数据类型，由基本数据类型组成</p>
<p><strong>读取属性的方法</strong><br>1、<code>obj[&#39;prop&#39;]</code>：最通用的方法，属性的键可以是不合法的标识符(如数字、带空格字符串)</p>
<p>2、<code>obj.prop</code>：简写的方法，但是要求键名必须是合法的标识符</p>
<p><strong>删除属性的方法</strong></p>
<p><code>delete obj[prop]</code></p>
<p><strong>检查对象是否具有某个属性</strong></p>
<p><code>prop in obj</code>检测对象种是包含某个键</p>
<p>使用<code>delete</code>删除属性后，用<code>in</code>检测被删除的属性返回<code>false</code><br>但给某属性赋值<code>undefined</code>后，用<code>in</code>检测返回的是<code>true</code></p>
<p><strong>遍历对象中的属性</strong></p>
<p><code>for(var key in person){ console.log(person[key]) }</code></p>
<p><strong>检测某个数据的类型的方法</strong></p>
<p><code>typeof()</code></p>
<p>两个特例：<code>1、typeof(null) -&gt; object</code>，<code>2、typeof(console.log) -&gt; function</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/14/JS数据类型/" data-id="cjx21g4vb0007bsvaggjtkuxo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS实现键盘导航" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/JS实现键盘导航/" class="article-date">
  <time datetime="2019-06-13T15:13:51.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/JS实现键盘导航/">JS实现键盘导航</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JS向页面写入DOM元素"><a href="#JS向页面写入DOM元素" class="headerlink" title="JS向页面写入DOM元素"></a>JS向页面写入DOM元素</h3><p>1、获取页面元素</p>
<p><code>var main = document.getElementById(&#39;main&#39;)</code></p>
<p>2、创建一个元素</p>
<p><code>var divEl = document.createElement(&#39;div&#39;)</code></p>
<p>3、向元素中写入内容</p>
<p><code>divEl.innerText = &#39;&#39;</code></p>
<p>4、将新创建的元素放入指定位置</p>
<p><code>main.appendChild(divEl)</code></p>
<hr>
<h3 id="区别几个写入内容API"><a href="#区别几个写入内容API" class="headerlink" title="区别几个写入内容API"></a>区别几个写入内容API</h3><h5 id="innerText-innerHTML"><a href="#innerText-innerHTML" class="headerlink" title="innerText / innerHTML"></a>innerText / innerHTML</h5><p>前者向元素中写入纯文本</p>
<p>后者向页面中写入html文本(会将html标签进行转义)</p>
<h5 id="innerText-textContent"><a href="#innerText-textContent" class="headerlink" title="innerText / textContent"></a>innerText / textContent</h5><p>前者能获取html文档渲染后文档中的文本(如元素中若使用了<code>text-transform</code>样式后的文本)</p>
<p>后者获取的是源html中的文本</p>
<hr>
<h3 id="循环中绑定事件"><a href="#循环中绑定事件" class="headerlink" title="循环中绑定事件"></a>循环中绑定事件</h3><p>循环中的变量是容器</p>
<p>而事件绑定是异步的，会等循环执行完后才执行</p>
<p>所以直接在事件函数中使用变量，使用的是循环结束时的变量</p>
<p>这种情况下应该使用<code>e.target</code>来获取目标元素，才能绑定成功</p>
<hr>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>本地缓存</p>
<p>通过<code>setItem(key, value)</code>来设置缓存</p>
<p>通过<code>getItem(key)</code>来读取缓存中的信息</p>
<hr>
<h3 id="favicon-icon"><a href="#favicon-icon" class="headerlink" title="favicon.icon"></a>favicon.icon</h3><p>网站头像，默认放在根目录下，浏览器默认会去取这个图标，展示在合适的位置上</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/JS实现键盘导航/" data-id="cjx21g4v70005bsva3d35ch3y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构和排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/12/数据结构和排序算法/" class="article-date">
  <time datetime="2019-06-11T20:02:47.000Z" itemprop="datePublished">2019-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/12/数据结构和排序算法/">数据结构和排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h5 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希 Hash"></a>哈希 <code>Hash</code></h5><p>满足键值对(<code>key:value</code>)形式的都是哈希</p>
<p><code>JS</code>中用对象 (属性和值)表示哈希，数组是对象<code>{0:&#39;e1&#39;, 1:&#39;e2&#39;, length: 2}</code>的简写</p>
<h5 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 <code>Queue</code></h5><p>先进先出</p>
<p>如排队，可用数组(<code>push</code>、<code>shift</code>)实现</p>
<h5 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 <code>Stack</code></h5><p>先进后出</p>
<p>如乘电梯、盗梦空间、递归原理，可用数组(<code>push</code>、<code>pop</code>)实现</p>
<h5 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 <code>Linked List</code></h5><p>数组是连续空间，无法直接删除中间某项，但链表可以</p>
<p>实现原理：</p>
<p><code>a1={value:1, next:a2}</code></p>
<p><code>a2={value:2, next:a3}</code></p>
<p><code>a3={value:3, next:undefined}</code></p>
<p>若要删除a2，只需将a1的<code>next</code>改为a3即可</p>
<p>可用哈希(JS中用对象表示哈希，嵌套对象)来实现链表</p>
<p>相关术语：表头<code>head</code>，表示链表的开头元素；节点<code>node</code>，表示其他元素</p>
<h5 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 <code>Tree</code></h5><p>层级结构，如<code>DOM</code>树</p>
<p>常用属性：层数、深度(一共多少层)、节点个数</p>
<h5 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 <code>Binary Tree</code></h5><p>每个节点最多只有两个分支</p>
<p>满二叉树：最后一层都是满的 (倒数第二层都有左子树和右子树)</p>
<p>完全二叉树：最后一层不一定满，但是连续的 (即不会出现只有两个左子树的情况)</p>
<h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 <code>Heap</code></h5><p>二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）</p>
<p>二叉堆有两种：最大堆和最小堆，一般用数组来表示</p>
<p>其他树可用哈希 (JS对象)来实现</p>
<hr>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>从右往左排</p>
<p>两两对比，若左边的元素大于右边的元素，就交换两元素的位置</p>
<p>第一次，即可将数组中最大的元素排到最右边</p>
<p>第二次，再排剩下的元素，可排好第二大的元素</p>
<p>依此类推 . . . 一共排<code>arr.length-1</code>次即可排完所有元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortByBubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//ES6交换两变量的值的方法</span></span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>从左往右排</p>
<p>第一次，遍历整个数组，找出最小的元素，获取其位置，再与首个元素交换位置，即可确定最小的元素</p>
<p>第二次，遍历剩下的元素，其他方法同上一步，即可确定第二个元素</p>
<p>依此类推 . . . 一共排<code>arr.length-1</code>次即可排完所有元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortBySelection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> min = arr[i]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            min = arr[j] &lt; min ? arr[j] : min</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处查找范围必须指定，不然具有相同值的数组会出现BUG</span></span><br><span class="line">        <span class="keyword">var</span> index = arr.indexOf(min, i)</span><br><span class="line">        arr[index] = arr[i]</span><br><span class="line">        arr[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入排序-起扑克牌法"><a href="#插入排序-起扑克牌法" class="headerlink" title="插入排序(起扑克牌法)"></a>插入排序(起扑克牌法)</h5><p>将原数组中的元素一个一个的放入新数组中</p>
<p>第一个元素，直接放入新数组不用排</p>
<p>第二个元素，和第一个元素比较，小于就放在它前面，大于就放在它后面</p>
<p>第三个元素，循环地与新数组中的所有元素比对：<br>    若是遇到大于它的元素，就停止比对，将它放到那(第一个大于它的)元素之前<br>    若是没有找到大于它的元素，就放到新数组最后</p>
<p>依此类推 . . . 将原数组中的所有元素都放入新数组后，新数组即为排序好的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortByInsertion</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arrNew = [arr[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arrNew.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrNew[j] &gt; arr[i]) &#123;</span><br><span class="line">                arrNew.splice(j, <span class="number">0</span>, arr[i])</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逻辑表达式返回能决定整个表达式真假的那个表达式的值</span></span><br><span class="line">        flag || arrNew.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrNew</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="计数排序-强迫症起扑克牌法"><a href="#计数排序-强迫症起扑克牌法" class="headerlink" title="计数排序(强迫症起扑克牌法)"></a>计数排序(强迫症起扑克牌法)</h5><p>用于范围不是很大的数组排序，用空间换时间。<br>无需二次排序，效率比较高；但大范围内排序很耗空间，且无法对小数和负数排序</p>
<p><em>入桶</em><br>将原数组中的每一个数，都作为<code>arrIn</code>数组的索引<br><code>arrIn</code>数组索引的值对应的是，原数组中特定(值为当前索引的)元素的个数</p>
<p><em>出桶</em><br>再从<code>arrIn</code>数组中提取出元素不为<code>undefined</code>的(对应元素个)索引值<br>放入<code>arrOut</code>数组中，<code>arrOut</code>数组即为排序好的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortByCounting</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//入桶</span></span><br><span class="line">    <span class="keyword">var</span> arrIn = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> index = arr[i]</span><br><span class="line">        <span class="keyword">if</span> (!arrIn[index]) &#123;</span><br><span class="line">            arrIn[index] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrIn[index]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出桶</span></span><br><span class="line">    <span class="keyword">var</span> arrOut = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arrIn.length; j++) &#123;</span><br><span class="line">        <span class="keyword">var</span> count = arrIn[j]</span><br><span class="line">        <span class="keyword">while</span> (count) &#123;</span><br><span class="line">            arrOut.push(j)</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrOut</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他排序"><a href="#其他排序" class="headerlink" title="其他排序"></a>其他排序</h5><p><strong>1、桶排序</strong><br>一个桶放一个范围内的数据，然后在桶内使用其他排序方法，</p>
<p>桶和桶之间的对比是独立的，减少对比次数，较计数排序减少了若干倍桶</p>
<p><strong>2、基数排序</strong><br>按十进制分出十个桶0~9，先按个位排入桶再出桶，再排十位入桶在出桶，依此类推 . . . </p>
<p>适用于大范围内的排序，可在很大程度上节约空间</p>
<p><strong>3、二分排序(快速排序)</strong><br>以一个元素为基准，小于它的排左边，大于它的排右边，排一次就能将这个元素在排好序的数组中的位置了</p>
<p>剩余的元素再按此方法排，只不过左边的只需要和左边比，右边的只需要和右边比，可以大大减少比对次数</p>
<p><strong>4、堆(二叉堆)排序</strong><br>建立在最大堆(父级总比子级大)调整的基础上，每次调整为最大堆后，就将堆顶的元素和最后一个元素换位</p>
<p>然后将最后一个元素从堆上删除，放在当前堆对应数组末尾，再进行下一次的最大堆调整，直至排完整个数组</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/12/数据结构和排序算法/" data-id="cjx21g4w0000cbsva0n91rg31" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS归纳整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/11/CSS归纳整理/" class="article-date">
  <time datetime="2019-06-10T23:55:44.000Z" itemprop="datePublished">2019-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/11/CSS归纳整理/">CSS归纳整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>层叠样式表：<code>Cascading Style Sheets</code></p>
<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>1、行内样式：<code>style=&quot;color:red;&quot;</code></p>
<p>2、内部样式表：<code>&lt;style&gt;*{ margin:0; padding:0; }&lt;/style&gt;</code></p>
<p>3、外部样式表：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/a.css&quot;&gt;</code></p>
<p>4、样式表中引入另一个样式表：<code>@import url(./b.css)</code></p>
<hr>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>1、给所有子元素添加<code>float</code>属性</p>
<p>2、给父元素添加<code>clearfix</code>类：<code>.clearfix::after{ content:&#39;&#39;; display:block; clear:both; }</code></p>
<h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p><code>Normal Flow</code>，指HTML文档内元素的流动方向</p>
<p>1、行内元素，从左向右流动，遇到阻碍就另起一行</p>
<p><code>word-break: break-all</code>将单词按字母打断，用于英文长单词遇到阻碍时能换行显示</p>
<p>2、块级元素，每个块独占一行，从上往下流动</p>
<p><code>display: inline-block</code>尽量少使用，优先考虑用<code>float: left</code>代替</p>
<hr>
<h3 id="块级元素的高度问题"><a href="#块级元素的高度问题" class="headerlink" title="块级元素的高度问题"></a>块级元素的高度问题</h3><p>1、用<code>height</code>属性指定的高度</p>
<p>2、等于其内部文档流元素的高度总和</p>
<p>有些行内元素的高度可能大于它所在的块级元素的高度，因为字体有浏览器设计的建议行高，布局时高度要用line-height明确指定</p>
<h3 id="行内元素内容居中问题"><a href="#行内元素内容居中问题" class="headerlink" title="行内元素内容居中问题"></a>行内元素内容居中问题</h3><p>尽量少使用<code>height</code>和<code>line-height</code></p>
<p>可考虑<code>display:inline-block; vertical-align: top;</code>与<code>padding、box-sizing: border-box;</code>来进行水平和垂直居中</p>
<hr>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>1、给子元素添加绝对定位：<code>display: absolute</code></p>
<p>2、给父元素添加相对定位：<code>display: relative</code></p>
<p>绝对定位会使元素脱离文档流，定位基准为最近的已定位的父级元素的左上角</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>给元素添加固定定位：<code>display: fixed</code></p>
<p>固定定位会使元素脱离文档流，定位基准为浏览器左上角，定位后元素位置不会随页面的滚动变化</p>
<hr>
<h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><h5 id="1、左右布局"><a href="#1、左右布局" class="headerlink" title="1、左右布局"></a>1、左右布局</h5><p>使用浮动，左边元素左浮动，右侧元素右浮动，父级元素清除浮动</p>
<h5 id="2、左右中布局"><a href="#2、左右中布局" class="headerlink" title="2、左右中布局"></a>2、左右中布局</h5><p>操作方式同布局1，左侧和中间元素左浮动，右侧元素右浮动，父级元素清除浮动</p>
<h5 id="3、水平居中"><a href="#3、水平居中" class="headerlink" title="3、水平居中"></a>3、水平居中</h5><p>行内元素，在父级元素上加<code>text-align</code>实现居中，或使用<code>padding</code>与<code>box-sizing</code>的组合进行居中</p>
<p>块级元素，通过<code>margin: 0 auto</code>实现水平居中</p>
<h5 id="4、垂直居中"><a href="#4、垂直居中" class="headerlink" title="4、垂直居中"></a>4、垂直居中</h5><p>通过将<code>height</code>和<code>line-height</code>指定为相同值来居中</p>
<p>通过设置元素的上下<code>padding</code>属性的值相等来实现居中</p>
<h5 id="5、其他小技巧"><a href="#5、其他小技巧" class="headerlink" title="5、其他小技巧"></a>5、其他小技巧</h5><p>伪元素：非空元素(可以有子元素的元素)默认都具有::before和::after伪元素<br>可以将其理解为一个无内容的<code>&lt;span&gt;</code>，和生命周期钩子一样，但无法被选中进行复制等操作</p>
<p>伪类：选择器的<code>:nth-child(even)</code>可以对偶数个子元素单独设置样式，实现更复杂的布局</p>
<p>对于浮动排版错乱的情况，使用<code>border</code>大法进行排查，看是否是由行高不一致导致的浮动异常</p>
<hr>
<h3 id="CSS资源"><a href="#CSS资源" class="headerlink" title="CSS资源"></a>CSS资源</h3><p>CSS经典范例：<a href="https://css-tricks.com/the-shapes-of-css/" target="_blank" rel="noopener">CSS Tricks</a></p>
<p>iconfont图标：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">矢量图标库</a></p>
<p>其他资源：阮一峰CSS、张鑫旭CSS、Codrops、《CSS揭秘》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/11/CSS归纳整理/" data-id="cjx21g4us0000bsvaa8kflez9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTML常用标签" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/10/HTML常用标签/" class="article-date">
  <time datetime="2019-06-10T14:49:29.000Z" itemprop="datePublished">2019-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/10/HTML常用标签/">HTML常用标签</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><h5 id="headline：-lt-h-gt"><a href="#headline：-lt-h-gt" class="headerlink" title="headline：&lt;h&gt;"></a>headline：<code>&lt;h&gt;</code></h5><p>用来表示不同级别的标题<code>&lt;h1&gt;~&lt;h6&gt;</code></p>
<h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><h5 id="paragraph：-lt-p-gt"><a href="#paragraph：-lt-p-gt" class="headerlink" title="paragraph：&lt;p&gt;"></a>paragraph：<code>&lt;p&gt;</code></h5><p>用来表示一个段落</p>
<hr>
<h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><h5 id="break：-lt-br-gt"><a href="#break：-lt-br-gt" class="headerlink" title="break：&lt;br&gt;"></a>break：<code>&lt;br&gt;</code></h5><p>用来实现网页上的换行</p>
<h3 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h3><h5 id="horizontal-line：-lt-hr-gt"><a href="#horizontal-line：-lt-hr-gt" class="headerlink" title="horizontal line：&lt;hr&gt;"></a>horizontal line：<code>&lt;hr&gt;</code></h5><p>用来在网页上画一条水平线</p>
<hr>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><h5 id="italic：-lt-i-gt-、emphasize：-lt-em-gt"><a href="#italic：-lt-i-gt-、emphasize：-lt-em-gt" class="headerlink" title="italic：&lt;i&gt;、emphasize：&lt;em&gt;"></a>italic：<code>&lt;i&gt;</code>、emphasize：<code>&lt;em&gt;</code></h5><p>前者表示样式上倾斜，后者表示语气上强调</p>
<h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><h5 id="blod：-lt-b-gt-、strong：-lt-strong-gt"><a href="#blod：-lt-b-gt-、strong：-lt-strong-gt" class="headerlink" title="blod：&lt;b&gt;、strong：&lt;strong&gt;"></a>blod：<code>&lt;b&gt;</code>、strong：<code>&lt;strong&gt;</code></h5><p>同样的，前者是样式上加粗，后者是语气上加重</p>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表：unordered list <code>&lt;ul&gt;</code>、列表项：list item <code>&lt;li&gt;</code></p>
<p><code>&lt;ul&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;</code></p>
<p>有序列表：ordered list <code>&lt;ol&gt;</code>、列表项：list item <code>&lt;li&gt;</code></p>
<p><code>&lt;ol&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ol&gt;</code></p>
<p>定义列表：definition list <code>&lt;dl&gt;</code>、定义标题：title <code>&lt;dt&gt;</code>、定义描述：description <code>&lt;dd&gt;</code></p>
<p><code>&lt;dl&gt;&lt;dt&gt;邮箱&lt;/dt&gt;&lt;dd&gt;startjcu@163.com&lt;/dd&gt;&lt;dl&gt;</code></p>
<hr>
<h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><p><code>&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;</code></p>
<p>图片：image <code>&lt;img&gt;</code>、资源：source <code>src</code>、替代文本：alternative <code>alt</code></p>
<h3 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h3><p><code>iframe</code>用于在一个页面中嵌入另一个页面</p>
<p><code>src</code>：指定跳转的路径</p>
<p><code>name</code>：必须和a标签的target属性结合使用</p>
<p><code>frameborder</code>：用来设定边框，一般设置为0</p>
<p><code>&lt;iframe name=&quot;my-iframe&quot; src=&quot;#&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></p>
<hr>
<h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p>锚：anchor <code>&lt;a&gt;</code>，用于页面跳转</p>
<h5 id="download属性"><a href="#download属性" class="headerlink" title="download属性"></a>download属性</h5><p>用来指定当前链接是用来下载的，不打开文件</p>
<h5 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h5><p>用来指定链接页面的打开方式</p>
<p>1、_blank，在新页面中打开链接</p>
<p>2、_self，在当前页面打开链接</p>
<p>3、_parent，在父级页面打开链接（有iframe的情况下才可看见效果）</p>
<p>4、_top，在顶级页面打开链接(有多个iframe嵌套的情况下效果可见）</p>
<h5 id="href属性"><a href="#href属性" class="headerlink" title="href属性"></a>href属性</h5><p>用来指定跳转路径</p>
<p>1、相对路径，<code>./</code>表示当前目录，<code>../</code>表示上级目录</p>
<p>2、协议+域名+路径，<code>//</code>表示继承当前文件使用的协议</p>
<p>3、# 锚点，用于当前页面不同位置的跳转</p>
<p>4、？参数，用于指定参数发起请求</p>
<p>5、javascript伪协议，如<code>javascript:;</code>用于取消a标签的跳转行为</p>
<hr>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><code>&lt;form&gt;</code>用于发起POST请求，上传数据，一个表单中必须要有一个提交按钮</p>
<p>提交按钮可以通过两种方式指定</p>
<p>1、<code>&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</code></p>
<p>2、<code>&lt;button&gt;submit&lt;/button&gt;</code>这种方式button的type属性值会默认指定为submit</p>
<h3 id="输入标签"><a href="#输入标签" class="headerlink" title="输入标签"></a>输入标签</h3><p><code>&lt;input&gt;</code>用于提供输入框，选项框和提交按钮</p>
<h5 id="type属性常用取值"><a href="#type属性常用取值" class="headerlink" title="type属性常用取值"></a>type属性常用取值</h5><p><strong>1、text</strong><br>普通输入框，输入的文本会以明文显示</p>
<p><strong>2、password</strong><br>密码输入框，输入的文本会以密文显示</p>
<p><strong>3、checkbox</strong><br>复选框，要设置相同的<code>name</code>值，且必须指定<code>value</code>值，供后台服务器拿数据用</p>
<p><strong>4、radio</strong><br>单选框，必须设置相同的<code>name</code>值，可以使用<code>checked</code>属性来设置默认选中项</p>
<h5 id="通过-lt-label-gt-标签嵌套-lt-input-gt-标签的形式，可以省去指定前者的for和后者的id，使代码更简洁"><a href="#通过-lt-label-gt-标签嵌套-lt-input-gt-标签的形式，可以省去指定前者的for和后者的id，使代码更简洁" class="headerlink" title="通过&lt;label&gt;标签嵌套&lt;input&gt;标签的形式，可以省去指定前者的for和后者的id，使代码更简洁"></a>通过<code>&lt;label&gt;</code>标签嵌套<code>&lt;input&gt;</code>标签的形式，可以省去指定前者的for和后者的id，使代码更简洁</h5><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><p><code>&lt;select&gt;</code>用于有多个可选项的情形</p>
<p><code>&lt;option&gt;</code>用来指定下拉列表项，<code>selected</code>指定默认选中项</p>
<p><code>&lt;select&gt;&lt;option selected&gt;one&lt;/option&gt;&lt;/select&gt;</code></p>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"border-collapse: collapse;text-align: center"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">70</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">bgcolor</span>=<span class="string">"yellow"</span> <span class="attr">width</span>=<span class="string">50</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">50</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>身高<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>one<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>170<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>平均<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>173<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/10/HTML常用标签/" data-id="cjx21g4v00001bsvat3z0wrsv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/18/JS-DOM/">JS-DOM</a>
          </li>
        
          <li>
            <a href="/2019/06/18/JS函数/">JS函数</a>
          </li>
        
          <li>
            <a href="/2019/06/17/JS数组和伪数组/">JS数组和伪数组</a>
          </li>
        
          <li>
            <a href="/2019/06/16/JS原型和原型链/">JS原型和原型链</a>
          </li>
        
          <li>
            <a href="/2019/06/15/JS类型转换与内存/">JS类型转换与内存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 冯义星<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>